---
layout: essay
type: essay
title: Watch the Meteor Crash
date: 2017-10-26
labels:
  - Meteor
---

## What happens in a crash 

<img class="ui medium left floated rounded image" width="300" src="../images/meteorhitearth.jpg">

“Look out! Ship Meteor crash landing from space in 5, 4, 3, 2… ” So, what happens next? Does the fictitious ship named Meteor crash onto Earth or does it disappear to someplace outside of Earth’s atmosphere? The most probable outcome to this dilemma is... it crashes to Earth, much like how an application crashes in Meteor (yes, this is a real program). Meteor is a means to create applications by using JavaScript and Semantic UI to add dynamic aspects to an app as explained in the Meteor [guide](https://guide.meteor.com/). The feeling when an application crashes, or doesn’t function the way you want it to function, in Meteor is similar to watching a ship crash to Earth because of some sort of malfunction. To put it simply, the feeling is of *utter devastation* where (1) your soul dies a little and (2) cleaning up the remnants of this so called crash is tough, I mean really tough. I can guarantee an app crashing or not working in Meteor is something everyone has experienced and relate to. It’s so common that the worse part in an app crash is 100% trying to figure out **_how_** to fix the problem.

## The Pain that Flies with Meteor

I’m not going to lie, Meteor is complicated. It’s also a very powerful tool, hence why it’s so complicated. There are *many* difficulties with using Meteor, one being the large amount of time it takes to create applications within its little framework. What exactly do I mean by that? Let’s take for instance the time it takes to build an app for the very first time (essentially creating a basis of it). 

Unfortunately, Meteor could take, in the worst case, one hour to just make the app using its resources and in the very best less than two minutes if one is lucky. In my case, applications would take about 10 minutes, if I get lucky. Usually, this is not a huge problem, however, building apps and creating the environment to run it on one’s laptop uses **_a ton_** of battery. I’m not even kidding. From my experience, the battery from my fairly new laptop has drained about 20% from building my application in Meteor alone; it’s pretty scary. Not to mention, the time it takes to “index” your environment on the IDE you’re running will take *_forever_* at first! Basically, Meteor is trying to make sure all the files in your directory and those that appear in your IDE are synchronized and running correctly on your host machine by indexing. It’s like...   

It’s also a tad bit difficult to learn how Meteor works. What I mean by this is understanding the fundamentals of how data is sent and received from the client and server sides. I find the relationship between the client and server summed up simply in Meteor’s guide. Essentially, the client receives, or in Meteor’s term “renders,” the data sent by the server and does some type of behavior with that data. Although this may seem far fetched, this is similar to understanding how the brain functions. Your brain has neurotransmitters, or carries chemical signals, which communicate with each other by sending and receiving signals from other neurotransmitters within the synapse, or the space between each neurotransmitter (yes, neurons don’t touch each other). Without the constant communication of these signals, you probably wouldn’t be alive or function normally since abnormalities in neural signaling have been shown to be a cause of some mental disorders.     


## Let's Soar Through Space

Despite needing to learn the relationship between the client and server and long build time, Meteor makes it easier to assemble all the parts of an app together. Since Meteor essentially breaks all the needed elements into parts, subelements can be added to every aspect of an application. For instance, creating more elements and directories to the client or server side that pertain to a specific function, such as adding contacts to a contact list. I find that having everything separated into its own part makes it easier to organize which elements go where and sort of forces the creator to figure out what elements should be seen by the client or the server. Since Meteor is the first client-server “application architecture” I have encountered, it makes it slightly easier to understand the client-server relationship and to create applications in this manner. Although, remembering to include all the necessary files in the right places can be annoying at times, especially when not including certain files is often the root cause of an application crashing/not behaving correctly.